#!/usr/bin/env python3
"""
InstalarTodo.py - Instalador autom√°tico para el proyecto Mistral Fine-tuning

Este script instala TODAS las dependencias necesarias para ejecutar
fine-tuning de Mistral-7B con Unsloth de forma autom√°tica.

Estructura del proyecto:
- Instalar Requesitos/ (este script)
- RealizarFineTuning/ (script principal)
- Dataset de Miramar/ (datasets personalizados)

Requisitos del sistema:
- GPU NVIDIA con drivers instalados
- CUDA 11.8+ o 12.0+
- Python 3.8+
- Conexi√≥n a internet estable
"""

import os
import sys
import subprocess
import platform
import importlib
import importlib.util

def print_banner():
    """Imprime el banner del instalador"""
    print("=" * 70)
    print("üöÄ INSTALADOR AUTOM√ÅTICO PARA MISTRAL FINE-TUNING")
    print("   Proyecto organizado con estructura de carpetas")
    print("   Instala todo lo necesario para el fine-tuning")
    print("=" * 70)
    print("üìÅ Estructura del proyecto:")
    print("   ‚îú‚îÄ‚îÄ Instalar Requesitos/ (instalaci√≥n)")
    print("   ‚îú‚îÄ‚îÄ RealizarFineTuning/ (entrenamiento)")
    print("   ‚îú‚îÄ‚îÄ Dataset de Miramar/ (datos)")
    print("   ‚îî‚îÄ‚îÄ outputs/ (resultados)")
    print("=" * 70)
    print("")

def print_section(title):
    """Imprime una secci√≥n con formato"""
    print("\n" + "üî• " + "=" * 60)
    print(f"   {title}")
    print("=" * 65)

def check_python_version():
    """Verifica la versi√≥n de Python"""
    print_section("VERIFICANDO VERSI√ìN DE PYTHON")
    
    version = sys.version_info
    print(f"üêç Python detectado: {version.major}.{version.minor}.{version.micro}")
    
    if version.major < 3 or (version.major == 3 and version.minor < 8):
        print("‚ùå ERROR: Se requiere Python 3.8 o superior")
        print("üí° Instala una versi√≥n m√°s reciente de Python")
        return False
    
    print("‚úÖ Versi√≥n de Python compatible")
    return True

def check_gpu():
    """Verifica la disponibilidad de GPU NVIDIA"""
    print_section("VERIFICANDO GPU NVIDIA")
    
    try:
        result = subprocess.run(['nvidia-smi'], capture_output=True, text=True)
        
        if result.returncode != 0:
            print("‚ùå No se detect√≥ GPU NVIDIA o drivers no instalados")
            print("üí° Instala los drivers NVIDIA desde: https://www.nvidia.com/drivers")
            print("‚ö†  El fine-tuning ser√° MUY lento sin GPU")
            
            choice = input("\n¬øContinuar sin GPU? (s/n): ").strip().lower()
            return choice in ['s', 'si', 's√≠', 'y', 'yes']
        else:
            # Extraer informaci√≥n de la GPU
            lines = result.stdout.split('\n')
            for line in lines:
                if 'GeForce' in line or 'RTX' in line or 'GTX' in line:
                    print(f"‚úÖ GPU detectada: {line.strip()}")
                    break
            
            # Verificar memoria
            for line in lines:
                if 'MiB' in line and '/' in line:
                    print(f"üìä Memoria GPU: {line.strip()}")
                    break
            
            return True
            
    except FileNotFoundError:
        print("‚ùå nvidia-smi no encontrado")
        print("üí° Instala CUDA toolkit y drivers NVIDIA")
        return False

def check_cuda():
    """Verifica la instalaci√≥n de CUDA"""
    print_section("VERIFICANDO CUDA")
    
    try:
        result = subprocess.run(['nvcc', '--version'], capture_output=True, text=True)
        
        if result.returncode == 0:
            # Extraer versi√≥n de CUDA
            output = result.stdout
            for line in output.split('\n'):
                if 'release' in line.lower():
                    print(f"‚úÖ CUDA detectado: {line.strip()}")
                    return True
        else:
            print("‚ö†  nvcc no encontrado, pero esto es opcional")
            print("üí° PyTorch puede usar CUDA sin nvcc en algunos casos")
            return True
            
    except FileNotFoundError:
        print("‚ö†  CUDA toolkit no detectado, pero puede funcionar")
        print("üí° PyTorch incluye su propia versi√≥n de CUDA")
        return True

def run_command(command, description, critical=True):
    """Ejecuta un comando y maneja errores"""
    print(f"\nüîß {description}...")
    print(f"üíª Comando: {command}")
    
    try:
        # Ejecutar comando
        result = subprocess.run(command, shell=True, check=True, 
                              capture_output=True, text=True)
        
        print("‚úÖ Instalaci√≥n exitosa")
        
        # Mostrar output si es relevante
        if result.stdout.strip():
            lines = result.stdout.strip().split('\n')
            if len(lines) <= 5:
                for line in lines:
                    if line.strip():
                        print(f"   {line}")
            else:
                print(f"   ... {len(lines)} l√≠neas de output")
        
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error en: {description}")
        print(f"üíÄ C√≥digo de error: {e.returncode}")
        
        if e.stderr:
            print(f"üìÑ Error detallado:")
            error_lines = e.stderr.strip().split('\n')
            for line in error_lines[-3:]:  # Mostrar √∫ltimas 3 l√≠neas
                print(f"   {line}")
        
        if critical:
            print("üõë Este error es cr√≠tico, deteniendo instalaci√≥n")
            return False
        else:
            print("‚ö†  Error no cr√≠tico, continuando...")
            return True

# Usar el pip del int√©rprete actual
PIP_CMD = f'"{sys.executable}" -m pip install'

def install_pytorch():
    """Instala PyTorch con soporte CUDA"""
    print_section("INSTALANDO PYTORCH CON CUDA")
    
    # Comando optimizado para CUDA 12.1
    pytorch_cmd = (
        f'{PIP_CMD} torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121'
    )
    
    return run_command(pytorch_cmd, "Instalando PyTorch con CUDA 12.1")

def install_unsloth():
    """Instala Unsloth y dependencias relacionadas"""
    print_section("INSTALANDO UNSLOTH")
    
    # Instalar desde git (versi√≥n m√°s actualizada)
    unsloth_cmd = f'{PIP_CMD} "unsloth[colab-new] @ git+https://github.com/unslothai/unsloth.git"'
    zoo_cmd = f'{PIP_CMD} --upgrade --force-reinstall unsloth_zoo'
    ok1 = run_command(unsloth_cmd, "Instalando Unsloth desde GitHub", critical=False)
    ok2 = run_command(zoo_cmd, "Instalando unsloth_zoo", critical=False)
    if not (ok1 and ok2):
        print("üí° Intentando instalaci√≥n desde PyPI...")
        fallback_cmd = f'{PIP_CMD} unsloth'
        fallback_zoo = f'{PIP_CMD} --upgrade --force-reinstall unsloth_zoo'
        ok3 = run_command(fallback_cmd, "Instalando Unsloth desde PyPI")
        ok4 = run_command(fallback_zoo, "Instalando unsloth_zoo desde PyPI")
        return ok3 and ok4
    return True

def install_transformers_ecosystem():
    """Instala Transformers y librer√≠as relacionadas"""
    print_section("INSTALANDO TRANSFORMERS Y DEPENDENCIAS")
    
    packages = [
        "transformers<=4.56.2",
        "datasets",
        "accelerate>=1.10.0",
        "peft>=0.7.1",
        "trl<=0.23.0",
        "bitsandbytes>=0.48.1",
        "sentencepiece>=0.2.1",
        "scipy",
        "scikit-learn",
        "autoawq>=0.2.9",
    ]
    for package in packages:
        # Forzar actualizaci√≥n y reinstalaci√≥n para evitar conflictos
        if any(package.startswith(prefix) for prefix in ("peft", "transformers", "accelerate", "trl", "bitsandbytes")):
            cmd = f'{PIP_CMD} --upgrade --force-reinstall "{package}"'
        else:
            cmd = f'{PIP_CMD} "{package}"'
        if not run_command(cmd, f"Instalando {package}"):
            return False
    return True

def install_compatibility_fixes():
    """Instala versiones espec√≠ficas para compatibilidad"""
    print_section("APLICANDO FIXES DE COMPATIBILIDAD")
    
    # Versiones espec√≠ficas para evitar conflictos
    fixes = [
        "protobuf==3.20.3",
        "numpy<2.0.0",
        "packaging",
        "psutil",
        "hf_transfer",
        "tyro"
    ]
    
    for fix in fixes:
        # Quote numpy version specifier to avoid shell redirection error
        if fix.startswith("numpy<"):
            fix_cmd = f'{PIP_CMD} "{fix}"'
        else:
            fix_cmd = f'{PIP_CMD} {fix}'
        if not run_command(fix_cmd, f"Instalando {fix}"):
            return False
    
    return True

def verify_installation():
    """Verifica que todas las librer√≠as se importan correctamente"""
    print_section("VERIFICANDO INSTALACI√ìN")
    
    # Lista de imports cr√≠ticos
    critical_imports = [
        ("torch", "PyTorch"),
        ("transformers", "Transformers"),
        ("datasets", "Datasets"),
        ("trl", "TRL"),
        ("peft", "PEFT"),
        ("bitsandbytes", "BitsAndBytes"),
        ("accelerate", "Accelerate"),
        ("sentencepiece", "SentencePiece"),
        ("awq", "AutoAWQ"),
        ("unsloth", "Unsloth"),
        ("unsloth_zoo", "Unsloth Zoo"),
    ]
    
    all_passed = True
    
    for module_name, display_name in critical_imports:
        try:
            # Intentar importar
            if module_name == "unsloth":
                # Import especial para Unsloth
                import unsloth
                from unsloth import FastLanguageModel
                print(f"‚úÖ {display_name}: OK")
            else:
                importlib.import_module(module_name)
                print(f"‚úÖ {display_name}: OK")
                
        except ImportError as e:
            print(f"‚ùå {display_name}: FALLO ({str(e)[:50]}...)")
            all_passed = False
        except Exception as e:
            print(f"‚ö†  {display_name}: Error inesperado ({str(e)[:30]}...)")
    
    # Verificar CUDA en PyTorch
    try:
        import torch
        if torch.cuda.is_available():
            print(f"‚úÖ CUDA en PyTorch: OK (GPU: {torch.cuda.get_device_name(0)})")
        else:
            print("‚ö†  CUDA en PyTorch: No disponible (funcionar√° con CPU)")
    except:
        print("‚ùå Error verificando CUDA en PyTorch")
        all_passed = False
    
    return all_passed

def create_test_script():
    """Crea un script de prueba r√°pida"""
    print_section("CREANDO SCRIPT DE PRUEBA")
    
    test_content = '''#!/usr/bin/env python3
"""Script de prueba r√°pida para verificar que todo funciona."""


def test_imports() -> bool:
    """Prueba todas las importaciones clave del proyecto."""

    print("üß™ Probando importaciones...")

    try:
        import torch
        print(f"‚úÖ PyTorch {torch.__version__}")
        print(f"‚úÖ CUDA disponible: {torch.cuda.is_available()}")

        import accelerate
        print(f"‚úÖ Accelerate {accelerate.__version__}")

        import sentencepiece as spm
        print(f"‚úÖ SentencePiece {spm.__version__}")

        import unsloth
        from unsloth import FastLanguageModel
        print("‚úÖ Unsloth importado correctamente")

        from transformers import AutoTokenizer
        print("‚úÖ Transformers OK")

        from datasets import Dataset
        print("‚úÖ Datasets OK")

        from trl import SFTTrainer
        print("‚úÖ TRL OK")

        import bitsandbytes
        print("‚úÖ BitsAndBytes OK")

        import awq
        print("‚úÖ AWQ OK")

        print("\nüéâ ¬°TODAS LAS IMPORTACIONES EXITOSAS!")
        print("üöÄ ¬°Listo para ejecutar el fine-tuning!")
        print("üìÅ Ve a la carpeta RealizarFineTuning/ y ejecuta:")
        print("   cd ../RealizarFineTuning")
        print("   python mistral_finetuning_final.py")

        return True

    except Exception as err:  # pragma: no cover - script auxiliar
        print(f"‚ùå Error: {err}")
        return False


if __name__ == "__main__":
    test_imports()
'''
    
    try:
        with open("test_instalacion.py", "w", encoding="utf-8") as f:
            f.write(test_content)
        print("‚úÖ Script de prueba creado: test_instalacion.py")
        return True
    except Exception as e:
        print(f"‚ùå Error creando script de prueba: {e}")
        return False

def show_final_instructions():
    """Muestra las instrucciones finales"""
    print_section("INSTALACI√ìN COMPLETADA")
    
    print("üéâ ¬°INSTALACI√ìN EXITOSA!")
    print()
    print("üìã PR√ìXIMOS PASOS:")
    print()
    print("1Ô∏è‚É£  Verificar instalaci√≥n:")
    print("   python VerificarTodo.py")
    print()
    print("2Ô∏è‚É£  Ejecutar fine-tuning:")
    print("   cd ../RealizarFineTuning")
    print("   python mistral_finetuning_final.py")
    print()
    print("üìÅ ESTRUCTURA DEL PROYECTO:")
    print("   ‚îú‚îÄ‚îÄ Instalar Requesitos/")
    print("   ‚îÇ   ‚îú‚îÄ‚îÄ InstalarTodo.py (este archivo)")
    print("   ‚îÇ   ‚îî‚îÄ‚îÄ VerificarTodo.py (verificador)")
    print("   ‚îú‚îÄ‚îÄ RealizarFineTuning/")
    print("   ‚îÇ   ‚îî‚îÄ‚îÄ mistral_finetuning_final.py (script principal)")
    print("   ‚îú‚îÄ‚îÄ Dataset de Miramar/")
    print("   ‚îÇ   ‚îî‚îÄ‚îÄ *.jsonl (tu dataset personalizado)")
    print("   ‚îî‚îÄ‚îÄ outputs/ (modelos entrenados)")
    print()
    print("üí° CONSEJOS:")
    print("   ‚Ä¢ El primer fine-tuning descargar√° ~14GB (modelo)")
    print("   ‚Ä¢ Aseg√∫rate de tener 50GB de espacio libre")
    print("   ‚Ä¢ El proceso completo toma 5-8 minutos en GPU")
    print()
    print("üÜò SI HAY PROBLEMAS:")
    print("   ‚Ä¢ Ejecuta: python3 test_instalacion.py")
    print("   ‚Ä¢ Verifica que la GPU est√© disponible")
    print("   ‚Ä¢ Reinicia el terminal si es necesario")
    print()
    print("üöÄ ¬°LISTO PARA ENTRENAR MODELOS!")

def force_reinstall_critical():
    """Fuerza la reinstalaci√≥n de peft, unsloth y unsloth_zoo"""
    print_section("REINSTALANDO PEFT, UNSLOTH Y UNSLOTH_ZOO (FORZADO)")
    cmd = (
        f'"{sys.executable}" -m pip install --upgrade --force-reinstall '
        'peft unsloth unsloth_zoo accelerate bitsandbytes autoawq sentencepiece'
    )
    return run_command(cmd, "Reinstalando peft, unsloth y unsloth_zoo")

def main():
    """Funci√≥n principal del instalador"""
    print_banner()
    
    # 1. Verificaciones del sistema
    if not check_python_version():
        sys.exit(1)
    
    gpu_available = check_gpu()
    check_cuda()
    
    # Confirmar instalaci√≥n
    print("\n" + "‚ö† " * 20)
    print("ESTE INSTALADOR VA A:")
    print("‚Ä¢ Instalar PyTorch (~2GB)")
    print("‚Ä¢ Instalar Unsloth y dependencias (~1GB)")
    print("‚Ä¢ Instalar Transformers ecosystem (~500MB)")
    print("‚Ä¢ Aplicar fixes de compatibilidad")
    print("‚Ä¢ Total estimado: ~3.5GB de descarga")
    print("‚ö† " * 20)
    
    if not gpu_available:
        print("\nüö® ADVERTENCIA: Sin GPU el entrenamiento ser√° EXTREMADAMENTE lento")
    
    continue_install = input("\n¬øContinuar con la instalaci√≥n? (s/n): ").strip().lower()
    
    if continue_install not in ['s', 'si', 's√≠', 'y', 'yes']:
        print("‚ùå Instalaci√≥n cancelada")
        sys.exit(0)
    
    print("\nüöÄ Iniciando instalaci√≥n autom√°tica...")
    
    # 2. Instalar dependencias
    steps = [
        (install_pytorch, "PyTorch con CUDA"),
        (install_transformers_ecosystem, "Transformers y dependencias"),
        (install_unsloth, "Unsloth"),
        (install_compatibility_fixes, "Fixes de compatibilidad"),
    ]
    
    for step_func, step_name in steps:
        print(f"\nüì¶ Instalando {step_name}...")
        if not step_func():
            print(f"\nüí• FALLO EN: {step_name}")
            print("üõë Instalaci√≥n detenida")
            sys.exit(1)

    # Fuerza reinstalaci√≥n de los paquetes cr√≠ticos
    force_reinstall_critical()

    # 3. Verificar instalaci√≥n
    print(f"\nüîç Verificando instalaci√≥n completa...")
    if not verify_installation():
        print("\n‚ö†  Algunas verificaciones fallaron")
        print("üí° Pero puede que a√∫n funcione. Prueba ejecutar:")
        print("   python3 test_instalacion.py")
    
    # 4. Crear script de prueba
    create_test_script()
    
    # 5. Mostrar instrucciones finales
    show_final_instructions()

if __name__ == "__main__":
    main()
